
CREATE TYPE public.timezone AS ENUM (
    'UTC+00:00',
    'UTC-12:00',
    'UTC-11:00',
    'UTC-10:00',
    'UTC-09:30',
    'UTC-09:00',
    'UTC-08:00',
    'UTC-07:00',
    'UTC-06:00',
    'UTC-05:00',
    'UTC-04:00',
    'UTC-03:30',
    'UTC-03:00',
    'UTC-02:00',
    'UTC-01:00',
    'UTC+01:00',
    'UTC+02:00',
    'UTC+03:00',
    'UTC+03:30',
    'UTC+04:00',
    'UTC+04:30',
    'UTC+05:00',
    'UTC+05:30',
    'UTC+05:45',
    'UTC+06:00',
    'UTC+06:30',
    'UTC+07:00',
    'UTC+08:00',
    'UTC+08:45',
    'UTC+09:00',
    'UTC+09:30',
    'UTC+10:00',
    'UTC+10:30',
    'UTC+11:00',
    'UTC+12:00',
    'UTC+12:45',
    'UTC+13:00',
    'UTC+14:00'
);


-- Create user_role type
CREATE TYPE public.user_role AS ENUM ('admin', 'moderator', 'creator', 'user');

-- Create app_permission type
CREATE TYPE public.app_permission AS ENUM ('select', 'insert', 'update', 'delete');

-- Create role_permissions table
CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role public.user_role NOT NULL,
  schema_name TEXT NOT NULL,
  table_name TEXT NOT NULL,
  permission app_permission NOT NULL,
  scope TEXT NOT NULL,
  postgres_role TEXT NOT NULL,
  UNIQUE (role, schema_name, table_name, permission, scope, postgres_role)
);

-- -- Create policy_strings table
-- CREATE TABLE public.policy_strings (
--     id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     policy_string TEXT NOT NULL UNIQUE,
--     created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--     updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
-- );

-- -- Create table_changes table to track schema changes
-- CREATE TABLE public.table_changes (
--     id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     operation TEXT NOT NULL,
--     schema_name TEXT NOT NULL,
--     table_name TEXT NOT NULL,
--     changed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
-- );

-- -- Create a trigger to update the updated_at column in policy_strings
-- CREATE OR REPLACE FUNCTION update_policy_strings_updated_at()
-- RETURNS TRIGGER AS $$
-- BEGIN
--     NEW.updated_at = CURRENT_TIMESTAMP;
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;

-- CREATE TRIGGER update_policy_strings_updated_at
-- BEFORE UPDATE ON public.policy_strings
-- FOR EACH ROW
-- EXECUTE FUNCTION update_policy_strings_updated_at();

-- CREATE OR REPLACE PROCEDURE create_single_policy(
--   p_schema_name TEXT,
--   p_table_name TEXT,
--   p_role TEXT,
--   p_action CHAR,
--   p_scope TEXT,
--   p_postgres_role CHAR
-- ) AS $$
-- DECLARE
--   v_policy_name TEXT;
--   v_policy_action TEXT;
--   v_policy_condition TEXT;
--   v_ownership_check TEXT;
--   v_full_postgres_role TEXT;
--   v_policy_definition TEXT;
-- BEGIN
--   -- Determine the policy action based on the action character
--   v_policy_action := CASE
--     WHEN p_action = 's' OR p_action = 'r' THEN 'SELECT'
--     WHEN p_action = 'i' OR p_action = 'w' THEN 'INSERT'
--     WHEN p_action = 'u' THEN 'UPDATE'
--     WHEN p_action = 'd' THEN 'DELETE'
--     ELSE 'UNKNOWN'
--   END;

--   -- Map the postgres_role character to the full role name
--   v_full_postgres_role := CASE
--     WHEN p_postgres_role = 'p' THEN 'postgres'
--     WHEN p_postgres_role = 'a' THEN 'authenticated'
--     WHEN p_postgres_role = 'n' THEN 'anon'
--     WHEN p_postgres_role = 's' THEN 'service_role'
--     WHEN p_postgres_role = 'u' THEN 'supabase_auth_admin'
--     WHEN p_postgres_role = 't' THEN 'supabase_storage_admin'
--     WHEN p_postgres_role = 'd' THEN 'dashboard_user'
--     WHEN p_postgres_role = 'm' THEN 'supabase_admin'
--     ELSE 'unknown_role'
--   END;

--   -- Determine the ownership check based on the table
--   IF p_schema_name = 'storage' AND p_table_name = 'objects' THEN
--     v_ownership_check := 'auth.uid() = owner';
--   ELSIF EXISTS (
--     SELECT 1
--     FROM information_schema.columns
--     WHERE table_schema = p_schema_name
--       AND table_name = p_table_name
--       AND column_name = 'user_id'
--   ) THEN
--     v_ownership_check := 'auth.uid() = user_id';
--   ELSE
--     v_ownership_check := 'TRUE';
--   END IF;

--   -- Construct the policy condition
--   v_policy_condition := format(
--     '(auth.jwt() ->> ''user_role'')::public.user_role = %L AND (%s)',
--     p_role,
--     CASE
--       WHEN p_scope = 'all' THEN 'TRUE'
--       WHEN p_scope = 'owned' THEN v_ownership_check
--       ELSE 'FALSE'
--     END
--   );

--   -- Construct the policy name
--   v_policy_name := format('Allow %s %s on %I.%I for %s (%s)', v_policy_action, p_scope, p_schema_name, p_table_name, p_role, v_full_postgres_role);

--   -- Log the details of the policy being created
--   RAISE NOTICE 'Creating policy:';
--   RAISE NOTICE '  Policy Name: %', v_policy_name;
--   RAISE NOTICE '  Schema Name: %', p_schema_name;
--   RAISE NOTICE '  Table Name: %', p_table_name;
--   RAISE NOTICE '  Role: %', p_role;
--   RAISE NOTICE '  Action: %', v_policy_action;
--   RAISE NOTICE '  Scope: %', p_scope;
--   RAISE NOTICE '  Postgres Role: %', v_full_postgres_role;
--   RAISE NOTICE '  Policy Condition: %', v_policy_condition;

--   -- Drop existing policy if it exists
--   EXECUTE format('DROP POLICY IF EXISTS %I ON %I.%I', v_policy_name, p_schema_name, p_table_name);

--   -- Construct the CREATE POLICY statement
--   v_policy_definition := format(
--     'CREATE POLICY %I ON %I.%I FOR %s TO %I',
--     v_policy_name,
--     p_schema_name,
--     p_table_name,
--     v_policy_action,
--     v_full_postgres_role
--   );

--   -- Add USING or WITH CHECK clause based on the action
--   IF p_action = 'i' OR p_action = 'w' THEN
--     v_policy_definition := v_policy_definition || format(' WITH CHECK (%s)', v_policy_condition);
--   ELSIF p_action = 'u' THEN
--     v_policy_definition := v_policy_definition || format(' USING (%s) WITH CHECK (%s)', v_policy_condition, v_policy_condition);
--   ELSE
--     v_policy_definition := v_policy_definition || format(' USING (%s)', v_policy_condition);
--   END IF;

--   -- Log the full policy definition
--   RAISE NOTICE 'Policy Definition: %', v_policy_definition;

--   -- Execute the CREATE POLICY statement
--   EXECUTE v_policy_definition;

--   -- Log success message
--   RAISE NOTICE 'Policy created successfully: %', v_policy_name;
-- END;
-- $$ LANGUAGE plpgsql;


-- CREATE OR REPLACE FUNCTION create_policies_from_stored_strings()
-- RETURNS VOID AS $$
-- DECLARE
--     v_policy_record RECORD;
--     v_parts TEXT[];
--     v_schema_name TEXT;
--     v_policy_table_name TEXT;
--     v_role TEXT;
--     v_actions TEXT;
--     v_scope TEXT;
--     v_postgres_roles TEXT;
--     v_action CHAR;
--     v_postgres_role CHAR;
--     v_permission app_permission;
--     v_user_role public.user_role;
-- BEGIN
--     RAISE NOTICE 'Starting create_policies_from_stored_strings()';

--     -- Drop the temporary table if it exists
--     DROP TABLE IF EXISTS temp_current_policies;

--     -- Create a temporary table to store current policies
--     CREATE TEMPORARY TABLE temp_current_policies (
--         role public.user_role,
--         schema_name TEXT,
--         table_name TEXT,
--         permission app_permission,
--         scope TEXT,
--         postgres_role TEXT
--     ) ON COMMIT DROP;

--     -- Populate the temporary table with current policies
--     INSERT INTO temp_current_policies
--     SELECT role, schema_name, table_name, permission, scope, postgres_role
--     FROM public.role_permissions;

--     RAISE NOTICE 'Current policies stored in temp_current_policies';

--     -- Clear existing policies and permissions
--     DELETE FROM public.role_permissions;
--     RAISE NOTICE 'Cleared existing policies from public.role_permissions';

--     -- Process existing policy strings
--     FOR v_policy_record IN SELECT policy_string FROM public.policy_strings LOOP
--         RAISE NOTICE 'Processing policy string: %', v_policy_record.policy_string;

--         -- Split the string into parts
--         v_parts := string_to_array(v_policy_record.policy_string, '.');
--         v_schema_name := v_parts[1];
--         v_policy_table_name := v_parts[2];
--         v_role := v_parts[3];
--         v_actions := v_parts[4];
--         v_scope := v_parts[5];
--         v_postgres_roles := v_parts[6];

--         -- Map the role string to user_role enum
--         v_user_role := CASE v_role
--             WHEN 'admin' THEN 'admin'::public.user_role
--             WHEN 'moderator' THEN 'moderator'::public.user_role
--             WHEN 'creator' THEN 'creator'::public.user_role
--             WHEN 'user' THEN 'user'::public.user_role
--             ELSE NULL::public.user_role
--         END;

--         -- If v_user_role is NULL, skip this iteration
--         IF v_user_role IS NULL THEN
--             RAISE NOTICE 'Invalid role % for %.%. Skipping.', v_role, v_schema_name, v_policy_table_name;
--             CONTINUE;
--         END IF;

--         -- Check if the table exists
--         IF EXISTS (
--             SELECT 1 
--             FROM information_schema.tables AS info_tables
--             WHERE info_tables.table_schema = v_schema_name AND info_tables.table_name = v_policy_table_name
--         ) THEN
--             -- Ensure RLS is enabled for the table
--             EXECUTE format('ALTER TABLE %I.%I ENABLE ROW LEVEL SECURITY', v_schema_name, v_policy_table_name);

--             -- Process actions and roles
--             FOR i IN 1..length(v_actions) LOOP
--                 v_action := substr(v_actions, i, 1);
--                 v_permission := CASE 
--                     WHEN v_action = 's' THEN 'select'
--                     WHEN v_action = 'i' THEN 'insert'
--                     WHEN v_action = 'u' THEN 'update'
--                     WHEN v_action = 'd' THEN 'delete'
--                     WHEN v_action = 'r' AND v_schema_name = 'storage' AND v_policy_table_name = 'objects' THEN 'select'
--                     WHEN v_action = 'w' AND v_schema_name = 'storage' AND v_policy_table_name = 'objects' THEN 'insert'
--                     ELSE NULL
--                 END::app_permission;

--                 IF v_permission IS NULL THEN
--                     RAISE NOTICE 'Invalid action % for %.%. Skipping.', v_action, v_schema_name, v_policy_table_name;
--                     CONTINUE;
--                 END IF;

--                 FOR j IN 1..length(v_postgres_roles) LOOP
--                     v_postgres_role := substr(v_postgres_roles, j, 1);
                    
--                     -- Create the permission
--                     INSERT INTO public.role_permissions (role, schema_name, table_name, permission, scope, postgres_role)
--                     VALUES (v_user_role, v_schema_name, v_policy_table_name, 
--                             v_permission, 
--                             v_scope,
--                             CASE
--                                 WHEN v_postgres_role = 'p' THEN 'postgres'
--                                 WHEN v_postgres_role = 'a' THEN 'authenticated'
--                                 WHEN v_postgres_role = 'n' THEN 'anon'
--                                 WHEN v_postgres_role = 's' THEN 'service_role'
--                                 WHEN v_postgres_role = 'u' THEN 'supabase_auth_admin'
--                                 WHEN v_postgres_role = 't' THEN 'supabase_storage_admin'
--                                 WHEN v_postgres_role = 'd' THEN 'dashboard_user'
--                                 WHEN v_postgres_role = 'm' THEN 'supabase_admin'
--                                 ELSE NULL
--                             END);

--                     RAISE NOTICE 'Created permission for role %, schema %, table %, permission %, scope %, postgres_role %',
--                         v_user_role, v_schema_name, v_policy_table_name, v_permission, v_scope, v_postgres_role;

--                     -- Create the policy
--                     CALL create_single_policy(v_schema_name, v_policy_table_name, v_role, v_action, v_scope, v_postgres_role);
--                 END LOOP;
--             END LOOP;
--         ELSE
--             RAISE NOTICE 'Table %.% does not exist. Skipping policy creation.', v_schema_name, v_policy_table_name;
--         END IF;
--     END LOOP;

--     -- Remove obsolete policies
--     FOR v_policy_record IN SELECT * FROM temp_current_policies LOOP
--         IF NOT EXISTS (
--             SELECT 1
--             FROM public.role_permissions
--             WHERE role_permissions.role = v_policy_record.role
--               AND role_permissions.schema_name = v_policy_record.schema_name
--               AND role_permissions.table_name = v_policy_record.table_name
--               AND role_permissions.permission = v_policy_record.permission
--               AND role_permissions.scope = v_policy_record.scope
--               AND role_permissions.postgres_role = v_policy_record.postgres_role
--         ) THEN
--             -- Remove the obsolete policy
--             CALL remove_single_policy(
--                 v_policy_record.schema_name,
--                 v_policy_record.table_name,
--                 v_policy_record.role::TEXT,
--                 (CASE
--                     WHEN v_policy_record.permission = 'select' THEN 's'
--                     WHEN v_policy_record.permission = 'insert' THEN 'i'
--                     WHEN v_policy_record.permission = 'update' THEN 'u'
--                     WHEN v_policy_record.permission = 'delete' THEN 'd'
--                 END),
--                 v_policy_record.postgres_role,
--                 v_policy_record.scope
--             );
--         END IF;
--     END LOOP;

--     -- Clean up tables with no policies
--     FOR v_policy_record IN 
--         SELECT DISTINCT schema_name, table_name 
--         FROM temp_current_policies
--         EXCEPT
--         SELECT DISTINCT schema_name, table_name 
--         FROM public.role_permissions
--     LOOP
--         -- Remove all policies for this table
--         EXECUTE format('DROP POLICY IF EXISTS ALL ON %I.%I', v_policy_record.schema_name, v_policy_record.table_name);
--         -- Disable RLS for tables with no policies
--         EXECUTE format('ALTER TABLE %I.%I DISABLE ROW LEVEL SECURITY', v_policy_record.schema_name, v_policy_record.table_name);
--         RAISE NOTICE 'Removed all policies and disabled RLS for table: %.%', v_policy_record.schema_name, v_policy_record.table_name;
--     END LOOP;

--     RAISE NOTICE 'Finished create_policies_from_stored_strings()';
-- END;
-- $$ LANGUAGE plpgsql SECURITY DEFINER;

-- -- Update the remove_single_policy procedure
-- CREATE OR REPLACE PROCEDURE remove_single_policy(
--     p_schema_name TEXT,
--     p_table_name TEXT,
--     p_role TEXT,
--     p_action CHAR,
--     p_postgres_role TEXT,
--     p_scope TEXT
-- ) AS $$
-- DECLARE
--     v_policy_name TEXT;
--     v_full_postgres_role TEXT;
-- BEGIN
--     -- Map the postgres_role to the full role name
--     v_full_postgres_role := CASE
--         WHEN p_postgres_role = 'p' THEN 'postgres'
--         WHEN p_postgres_role = 'a' THEN 'authenticated'
--         WHEN p_postgres_role = 'n' THEN 'anon'
--         WHEN p_postgres_role = 's' THEN 'service_role'
--         WHEN p_postgres_role = 'u' THEN 'supabase_auth_admin'
--         WHEN p_postgres_role = 't' THEN 'supabase_storage_admin'
--         WHEN p_postgres_role = 'd' THEN 'dashboard_user'
--         WHEN p_postgres_role = 'm' THEN 'supabase_admin'
--         ELSE p_postgres_role
--     END;

--     -- Construct the policy name
--     v_policy_name := format('Allow %s %s on %I.%I for %s (%s)',
--         CASE
--             WHEN p_action = 's' THEN 'SELECT'
--             WHEN p_action = 'i' THEN 'INSERT'
--             WHEN p_action = 'u' THEN 'UPDATE'
--             WHEN p_action = 'd' THEN 'DELETE'
--             ELSE 'UNKNOWN'
--         END,
--         p_scope,
--         p_schema_name,
--         p_table_name,
--         p_role,
--         v_full_postgres_role
--     );

--     -- Drop the policy
--     EXECUTE format('DROP POLICY IF EXISTS %I ON %I.%I', v_policy_name, p_schema_name, p_table_name);

--     RAISE NOTICE 'Removed policy: %', v_policy_name;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Trigger function to call create_policies_from_stored_strings on changes to policy_strings
-- CREATE OR REPLACE FUNCTION trigger_update_policies()
-- RETURNS TRIGGER AS $$
-- BEGIN
--     PERFORM create_policies_from_stored_strings();
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql SECURITY DEFINER;

-- -- Create the trigger on policy_strings table
-- CREATE TRIGGER update_policies_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.policy_strings
-- FOR EACH STATEMENT
-- EXECUTE FUNCTION trigger_update_policies();

-- -- Function to handle table changes
-- CREATE OR REPLACE FUNCTION handle_table_change()
-- RETURNS TRIGGER AS $$
-- BEGIN
--     INSERT INTO public.table_changes (operation, schema_name, table_name)
--     VALUES (TG_OP, TG_TABLE_SCHEMA, TG_TABLE_NAME);

--     -- Recreate all policies
--     PERFORM create_policies_from_stored_strings();
    
--     RETURN NULL;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Create triggers for table changes
-- CREATE OR REPLACE FUNCTION create_table_change_trigger(p_schema_name TEXT, p_table_name TEXT)
-- RETURNS VOID AS $$
-- BEGIN
--     EXECUTE format('
--         CREATE TRIGGER table_change_trigger
--         AFTER CREATE OR ALTER OR DROP ON %I.%I
--         FOR EACH STATEMENT
--         EXECUTE FUNCTION handle_table_change()', p_schema_name, p_table_name);
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Function to create triggers for all existing tables
-- CREATE OR REPLACE FUNCTION create_triggers_for_existing_tables()
-- RETURNS VOID AS $$
-- DECLARE
--     v_table RECORD;
-- BEGIN
--     FOR v_table IN 
--         SELECT table_schema, table_name 
--         FROM information_schema.tables
--         WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
--           AND table_type = 'BASE TABLE'
--     LOOP
--         PERFORM create_table_change_trigger(v_table.table_schema, v_table.table_name);
--     END LOOP;
-- END;
-- $$ LANGUAGE plpgsql;

-- -- Secure the tables and functions
-- REVOKE ALL ON public.policy_strings FROM PUBLIC;
-- REVOKE ALL ON public.role_permissions FROM PUBLIC;
-- REVOKE ALL ON public.table_changes FROM PUBLIC;
-- REVOKE ALL ON FUNCTION create_policies_from_stored_strings() FROM PUBLIC;
-- REVOKE ALL ON FUNCTION handle_table_change() FROM PUBLIC;
-- REVOKE ALL ON FUNCTION create_table_change_trigger(TEXT, TEXT) FROM PUBLIC;
-- REVOKE ALL ON FUNCTION create_triggers_for_existing_tables() FROM PUBLIC;

-- GRANT SELECT ON public.policy_strings TO authenticated;
-- GRANT SELECT ON public.role_permissions TO authenticated;
-- GRANT SELECT ON public.table_changes TO authenticated;
-- GRANT EXECUTE ON FUNCTION create_policies_from_stored_strings() TO authenticated;
-- GRANT EXECUTE ON FUNCTION handle_table_change() TO authenticated;
-- GRANT EXECUTE ON FUNCTION create_table_change_trigger(TEXT, TEXT) TO authenticated;
-- GRANT EXECUTE ON FUNCTION create_triggers_for_existing_tables() TO authenticated;

-- -- Create RLS policies for policy_strings table
-- ALTER TABLE public.policy_strings ENABLE ROW LEVEL SECURITY;

-- CREATE POLICY "Service role can manage policy strings" ON public.policy_strings
--     USING (current_user = 'service_role')
--     WITH CHECK (current_user = 'service_role');

-- CREATE POLICY "All users can view policy strings" ON public.policy_strings
--     FOR SELECT USING (TRUE);


